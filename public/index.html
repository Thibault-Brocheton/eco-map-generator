<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MAP Generator</title>

  <script src="fabric.min.js"></script>
  <script src="three.js"></script>
  <script src="OrbitControls.js"></script>
  <script src="stats.min.js"></script>

  <style>
        body {
          margin: 0;
        }

        canvas {
          border: 1px solid black;
        }

        #drawing {
          display: flex;
          flex-flow: row;
        }

        .colorPicker {
          width: 60px;
          height: 30px;
          border: 1px solid black;
        }
    </style>
</head>
<body>

MAP GENERATOR<br/>

<input type="number" id="size" value="720" />
<button onclick="reset()">init/reset</button> -
<button><label for="inputBiome">Import Biome</label></button><input style="display: none;" type="file" id="inputBiome" accept = "image/png"> -
<button><label for="inputWater">Import Water</label></button><input style="display: none;" type="file" id="inputWater" accept = "image/png"> -
<button><label for="inputHeightmap">Import Heightmap</label></button><input style="display: none;" type="file" id="inputHeightmap" accept = "image/png"><br />

<div id="content" style="display: none">
  <div id="mapbar">
    <button id="toggle-water" onclick="toggleWater()">Show Water</button>
    <button id="toggle-3d" onclick="toggle3d()">Show 3d</button><br />
  </div>
  <div id="drawing">
    <div id="maps" style="position: relative;">
      <canvas id="map_biomes" width="720" height="720" style="display: none"></canvas>
      <canvas id="map_water" width="720" height="720" style="display: none; position: absolute; top: 0; left: 0;"></canvas>
      <canvas id="hidden_height" width="720" height="720" style="display: none; position: absolute; top: 0; left: 0;"></canvas>
      <div id="map_height" style="background-color:white; display: none; position: absolute; top: 0; left: 0;"></div>
    </div>
    <div id="toolbar2d">
      2D TOOLBAR<br/>
      <button onclick="toolPen()">PEN</button>
      <button onclick="toolFill()" id="toolFill">FILL</button><br />
      <input type="number" id="brushWidth" onchange="changeBrushWidth()" value="10" /><br />
      <div id="color-biomes" style="display: block">
        <button class="colorPicker" style="background-color: #000000" onclick="switchColor('#000000')"></button> Empty<br />
        <button class="colorPicker" style="background-color: #4682b4" onclick="switchColor('#4682b4')"></button> DeepOcean<br />
        <button class="colorPicker" style="background-color: #87cefa" onclick="switchColor('#87cefa')"></button> Ocean<br />
        <button class="colorPicker" style="background-color: #fafad2" onclick="switchColor('#fafad2')"></button> Coast<br />
        <button class="colorPicker" style="background-color: #90ee90" onclick="switchColor('#90ee90')"></button> Grasslands<br />
        <button class="colorPicker" style="background-color: #b8860b" onclick="switchColor('#b8860b')"></button> WarmForest<br />
        <button class="colorPicker" style="background-color: #f4a460" onclick="switchColor('#f4a460')"></button> Desert<br />
        <button class="colorPicker" style="background-color: #20b2aa" onclick="switchColor('#20b2aa')"></button> RainForest<br />
        <button class="colorPicker" style="background-color: #006400" onclick="switchColor('#006400')"></button> Wetland<br />
        <button class="colorPicker" style="background-color: #228b22" onclick="switchColor('#228b22')"></button> ColdForest<br />
        <button class="colorPicker" style="background-color: #6b8e23" onclick="switchColor('#6b8e23')"></button> Taiga<br />
        <button class="colorPicker" style="background-color: #bdb76b" onclick="switchColor('#bdb76b')"></button> Tundra<br />
        <button class="colorPicker" style="background-color: #ffffff" onclick="switchColor('#ffffff')"></button> Ice<br />
      </div>
      <div id="color-water" style="display: none">
        <button class="colorPicker" style="background-color: #000000" onclick="switchColor('#000000')"></button> Empty<br />
        <button class="colorPicker" style="background-color: #4682b4" onclick="switchColor('#4682b4')"></button> River<br />
        <button class="colorPicker" style="background-color: #87cefa" onclick="switchColor('#87cefa')"></button> Lake<br />
      </div>
    </div>
    <div id="toolbar3d" style="display: none">
      3D TOOLBAR<br/>
      <button onclick="toolMove()">MOVE</button>
      <button onclick="toolElevation()">Elevation</button>
      <button onclick="toolColor()">Color (Debug)</button><br />
      Width:<input type="number" id="elevationWidth" onchange="changeElevationWidth()" style="display: none;" value="10" /><br />
      Height:<input type="number" id="elevationHeight" onchange="changeElevationHeight()" style="display: none;" value="10" /><br />
      <button onclick="togglePlaneWater()">Toggle Water</button><br />
      <button onclick="generateHeightmapBasic()">Generate HeightMap (basic)</button>
    </div>
  </div>
  <div id="export">
    <button onclick="exportBiome()">Export Biome</button>
    <button onclick="exportWater()">Export Water</button>
    <button onclick="exportHeight()">Export Height</button>
  </div>
</div>


<script>
  const canvasB = document.getElementById("map_biomes");
  const canvasW = document.getElementById("map_water");
  const canvasHidden = document.getElementById("hidden_height");

  const mapHeight = document.getElementById('map_height');

  const maxHeight = 160;
  const waterHeight = 60;

  let color = '#000000';
  let width = 10;
  let elevationHeight = 10;
  let elevationWidth = 10;
  let tool = 'pen';
  let tool3d = 'move';
  let size = 720;

  const biomeColorToName = {
    "#4682b4": "DeepOcean",
    "#87cefa": "Ocean",
    "#fafad2": "Coast",
    "#90ee90": "Grasslands",
    "#b8860b": "WarmForest",
    "#f4a460": "Desert",
    "#20b2aa": "RainForest",
    "#006400": "Wetland",
    "#228b22": "ColdForest",
    "#6b8e23": "Taiga",
    "#bdb76b": "Tundra",
    "#ffffff": "Ice",
  }

  const biomeHeightAssoc = {
    "DeepOcean": {
      min: -1,
      max: -0.4,
    },
    "Ocean": {
      min: -0.2,
      max: -0.05,
    },
    "Coast": {
      min: 0.01,
      max: 0.01,
    },
    "Grasslands": {
      min: 0.02,
      max: 0.4,
    },
    "WarmForest": {
      min: 0.1,
      max: 0.5,
    },
    "Desert": {
      min: 0.02,
      max: 0.2,
    },
    "RainForest": {
      min: 0.1,
      max: 0.5,
    },
    "Wetland": {
      min: 0.02,
      max: 0.3,
    },
    "ColdForest": {
      min: 0.1,
      max: 0.7,
    },
    "Taiga": {
      min: 0.3,
      max: 1,
    },
    "Tundra": {
      min: 0.4,
      max: 1,
    },
    "Ice": {
      min: 0.6,
      max: 1,
    },
  };

  let scene;
  let camera;
  let renderer;
  let controls;
  let instanceMesh;

  const instanceXZ = {};

  let activeCanvas;
  let activeContext;

  const ctxB = canvasB.getContext("2d");
  ctxB.imageSmoothingEnabled = false;
  const ctxW = canvasW.getContext("2d");
  const ctxHidden = canvasHidden.getContext("2d");

  canvasB.addEventListener("mousemove", function (e) {
    drawWithTool('move', e);
  }, false);
  canvasB.addEventListener("mousedown", function (e) {
    drawWithTool('down', e);
  }, false);
  canvasB.addEventListener("mouseup", function (e) {
    drawWithTool('up', e);
  }, false);
  canvasB.addEventListener("mouseout", function (e) {
    drawWithTool('out', e);
  }, false);

  canvasW.addEventListener("mousemove", function (e) {
    drawWithTool('move', e);
  }, false);
  canvasW.addEventListener("mousedown", function (e) {
    drawWithTool('down', e);
  }, false);
  canvasW.addEventListener("mouseup", function (e) {
    drawWithTool('up', e);
  }, false);
  canvasW.addEventListener("mouseout", function (e) {
    drawWithTool('out', e);
  }, false);

  mapHeight.addEventListener("mousemove", function (e) {
    drawWith3dTool('move', e);
  }, false);
  mapHeight.addEventListener("mousedown", function (e) {
    drawWith3dTool('down', e);
  }, false);
  mapHeight.addEventListener("mouseup", function (e) {
    drawWith3dTool('up', e);
  }, false);
  mapHeight.addEventListener("mouseout", function (e) {
    drawWith3dTool('out', e);
  }, false);

  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  init3dView();

  function exportBiome() {
    var link = document.createElement('a');
    link.download = 'Biomes_import.png';
    link.href = canvasB.toDataURL();
    link.click();
    link.remove();
  }

  function exportWater() {
    var link = document.createElement('a');
    link.download = 'Water_import.png';
    link.href = canvasW.toDataURL();
    link.click();
    link.remove();
  }

  function exportHeight() {
    var link = document.createElement('a');
    link.download = 'Heightmap_import.png';

    const myImageData = ctxHidden.getImageData(0, 0, size, size);
    const matrix = new THREE.Matrix4();

    for (let i = 0; i < size * size; i++) {
      instanceMesh.getMatrixAt(i, matrix);
      const yValue = matrix.elements[13];

      const normalizedY = yValue / maxHeight * 255;

      myImageData.data[i * 4]     = 255;
      myImageData.data[i * 4 + 1] = 255;
      myImageData.data[i * 4 + 2] = 255;
      myImageData.data[i * 4 + 3] = normalizedY;
    }

    ctxHidden.putImageData(myImageData, 0, 0);

    link.href = canvasHidden.toDataURL();
    link.click();
    link.remove();
  }

  let inputBiome = document.getElementById('inputBiome');
  inputBiome.addEventListener('change', function(e) {
    if(e.target.files) {
      let imageFile = e.target.files[0]; //here we get the image file
      var reader = new FileReader();
      reader.readAsDataURL(imageFile);
      reader.onloadend = function (e) {
        var myImage = new Image(); // Creates image object
        myImage.src = e.target.result; // Assigns converted image to image object
        myImage.onload = function(ev) {
          reset();

          canvasB.width = myImage.width; // Assigns image's width to canvas
          canvasB.height = myImage.height; // Assigns image's height to canvas
          ctxB.drawImage(myImage,0,0); // Draws the image on canvas
        }
      }
    }
  });

  let inputWater = document.getElementById('inputWater');
  inputWater.addEventListener('change', function(e) {
    if(e.target.files) {
      let imageFile = e.target.files[0]; //here we get the image file
      var reader = new FileReader();
      reader.readAsDataURL(imageFile);
      reader.onloadend = function (e) {
        var myImage = new Image(); // Creates image object
        myImage.src = e.target.result; // Assigns converted image to image object
        myImage.onload = function(ev) {
          canvasW.width = myImage.width; // Assigns image's width to canvas
          canvasW.height = myImage.height; // Assigns image's height to canvas
          ctxW.drawImage(myImage,0,0); // Draws the image on canvas
        }
      }
    }
  });

  let inputHeightmap = document.getElementById('inputHeightmap');
  inputHeightmap.addEventListener('change', function(e) {
    if(e.target.files) {
      let imageFile = e.target.files[0]; //here we get the image file
      var reader = new FileReader();
      reader.readAsDataURL(imageFile);
      reader.onloadend = function (e) {
        var myImage = new Image(); // Creates image object
        myImage.src = e.target.result; // Assigns converted image to image object
        myImage.onload = function() {
          canvasHidden.width = myImage.width; // Assigns image's width to canvas
          canvasHidden.height = myImage.height; // Assigns image's height to canvas
          ctxHidden.drawImage(myImage,0,0); // Draws the image on canvas

          heightMapTo3d();
        };
      };
    }
  });

  function heightMapTo3d() {
    if (!instanceMesh) {
      alert('Initialize 3D View first');
      return;
    }

    const myImageData = ctxHidden.getImageData(0, 0, size, size);
    const matrix = new THREE.Matrix4();

    for (let i = 0; i < size * size; i++) {
      instanceMesh.getMatrixAt(i, matrix);
      const greyValue = myImageData.data[i * 4 + 3];

      console.log(greyValue);

      matrix.elements[13] = greyValue * maxHeight / 255;
      instanceMesh.setMatrixAt(i, matrix);
    }

    instanceMesh.instanceMatrix.needsUpdate = true;
  }

  function init3dView() {
    function createStats() {
      var stats = new Stats();
      stats.setMode(0);

      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0';
      stats.domElement.style.top = '0';

      return stats;
    }

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    scene.add(new THREE.HemisphereLight(0xffffcc, 0x19bbdc, 1));

    camera = new THREE.PerspectiveCamera( 90, 1, 0.1, 10000 );
    //camera = new THREE.OrthographicCamera();

    renderer = new THREE.WebGLRenderer({ antialias : false });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( size, size );

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.zoomSpeed = 1;
    controls.panSpeed = 1;

    const updateCameraOrbit = () => {
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
    };

    controls.addEventListener('end', () => {
      updateCameraOrbit();
    });

    stats = createStats();

    updateCameraOrbit();

    function animate() {
      requestAnimationFrame(animate);

      controls.update();

      renderer.render( scene, camera );
      stats.update();
    }

    animate();

    mapHeight.appendChild( renderer.domElement );
    mapHeight.appendChild( stats.domElement );
  }

  let is3dDrawing = false;

  function drawWith3dTool(res, e) {
    if (res === 'up' || res === 'out') {
      is3dDrawing = false;
    }

    if (res === 'down') {
      is3dDrawing = true;

      res = 'move';
    }

    if (res === 'move' && is3dDrawing) {
      if (tool3d === 'elevation') {
        raycaster.setFromCamera( pointer, camera );

        const intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length) {
          console.log(intersects[0]);

          const centerMatrix = new THREE.Matrix4();
          intersects[0].object.getMatrixAt(intersects[0].instanceId, centerMatrix);

          const centerX = centerMatrix.elements[12];
          const centerZ = centerMatrix.elements[14];

          const matrix = new THREE.Matrix4();

          for (let i = -elevationWidth; i <= elevationWidth; i++) {
            for (let j = -elevationWidth; j <= elevationWidth; j++) {
              if (distance(centerX, centerZ, centerX + i, centerZ + j) < elevationWidth) {
                let instanceId = instanceXZ[`${centerX + i}:${centerZ + j}`];

                if (instanceId) {
                  intersects[0].object.getMatrixAt(instanceId, matrix);

                  handleHeightAddition(matrix, elevationHeight);

                  intersects[0].object.setMatrixAt(instanceId, matrix);
                }
              }
            }
          }

          intersects[0].object.instanceMatrix.needsUpdate = true;
        }
      } else if (tool3d === 'color') {
        raycaster.setFromCamera( pointer, camera );

        const intersects = raycaster.intersectObjects( scene.children ).filter(a => a.faceIndex === 5 || a.faceIndex === 4);
        const threeColor = new THREE.Color();

        for (let i = 0; i < intersects.length; i ++) {
          if (i=== 0) {
            console.log(intersects[i]);
          }

          intersects[i].object.setColorAt(intersects[i].instanceId, threeColor.setHex(0xff0000));
        }

        if (intersects.length) {
          intersects[0].object.instanceColor.needsUpdate = true;
        }
      }
    }
  }

  function handleHeightSet(matrix, height) {
    if (height > maxHeight) {
      matrix.elements[5] = maxHeight;
      matrix.elements[13] = maxHeight / 2;
    } else if (height < 1) {
      matrix.elements[5] = 1;
      matrix.elements[13] = 0.5;
    } else {
      matrix.elements[5] = height;
      matrix.elements[13] = matrix.elements[5] / 2;
    }
  }

  function handleHeightAddition(matrix, elevation) {
    handleHeightSet(matrix, matrix.elements[5] + elevation);
  }

  function generateHeightmapBasic() {
    const myImageData = ctxB.getImageData(0, 0, size, size);
    const matrix = new THREE.Matrix4();

    for (let i = 0; i < size * size; i++) {
      instanceMesh.getMatrixAt(i, matrix);

      const color = rgbToHex(myImageData.data[i * 4], myImageData.data[i * 4 + 1], myImageData.data[i * 4 + 2]);

      if (!biomeColorToName[color]) continue;

      const biomeHeight = biomeHeightAssoc[biomeColorToName[color]];

      const coeff = ((biomeHeight.min + biomeHeight.max) / 2);

      if (coeff > 0) {
        handleHeightSet(matrix, (coeff * (maxHeight - waterHeight) + waterHeight));
      } else {
        handleHeightSet(matrix, waterHeight + coeff * waterHeight);
      }

      instanceMesh.setMatrixAt(i, matrix);
    }

    instanceMesh.instanceMatrix.needsUpdate = true;
  }

  function update3dView() {
    renderer.setSize( size, size );
  }

  function onPointerMove( event ) {
    // calculate pointer position in normalized device coordinates
    // (-1 to +1) for both components
    const box = mapHeight.getBoundingClientRect();

    pointer.x = ( (event.clientX - box.left) / size ) * 2 - 1;
    pointer.y = - ( (event.clientY - box.top) / size ) * 2 + 1;

  }

  window.addEventListener( 'pointermove', onPointerMove );

  function reset() {
    size = document.getElementById("size").value;

    for (let canvas of [canvasB, canvasW, canvasHidden]) {
      canvas.width = size;
      canvas.height = size;
    }

    mapHeight.style.width = size + 'px';
    mapHeight.style.height = size + 'px';

    ctxB.fillStyle = 'rgb(0,0,0)';
    ctxB.fillRect(0, 0, size, size);

    ctxW.fillStyle = 'rgba(0,0,0,0)';
    ctxW.fillRect(0, 0, size, size);

    showBiomes();

    update3dView();

    var content = document.getElementById("content");
    content.style.display = 'block';
  }

  function showBiomes() {
    activeCanvas = canvasB;
    activeContext = ctxB;
    canvasB.style.display = 'block';
    canvasW.style.display = 'none';
    mapHeight.style.display = 'none';
  }

  function toggleWater() {
    toolPen();

    if (canvasW.style.display === 'block') {
      canvasW.style.display = 'none';
      activeCanvas = canvasB;
      activeContext = ctxB;
      document.getElementById('color-water').style.display = 'none';
      document.getElementById('toolFill').style.display = 'block';
      document.getElementById('color-biomes').style.display = 'block';
      switchColor("#000000");
      document.getElementById('toggle-water').innerHTML = "Show Water";
    } else {
      canvasW.style.display = 'block';
      activeCanvas = canvasW;
      activeContext = ctxW;
      switchColor('#000000');
      document.getElementById('color-water').style.display = 'block';
      document.getElementById('toolFill').style.display = 'none';
      document.getElementById('color-biomes').style.display = 'none';
      document.getElementById('toggle-water').innerHTML = "Hide Water";
    }
  }

  let planeWater;

  function togglePlaneWater() {
    if (planeWater) {
      scene.remove(planeWater);
      planeWater = undefined;
    } else {
      const geoWater = new THREE.PlaneGeometry(size,size);
      const matWater = new THREE.MeshBasicMaterial({ color: 0x99FFFF, side: THREE.DoubleSide, opacity: 0.5, transparent: true });
      planeWater = new THREE.Mesh(geoWater, matWater);
      planeWater.position.x = size / 2;
      planeWater.position.y = waterHeight;
      planeWater.position.z = size / 2;
      planeWater.rotateX( - Math.PI / 2);

      scene.add(planeWater);
    }
  }

  function refresh3dContent() {
    const axesHelper = new THREE.AxesHelper( 5 );
    axesHelper.setColors('red', 'green', 'blue')
    scene.add( axesHelper );

    if (instanceMesh) {
      scene.remove(instanceMesh);
    }

    const biomeImageData = ctxB.getImageData(0, 0, size, size);
    const biomeWaterData = ctxW.getImageData(0, 0, size, size);

    const workArray = [];
    let x = 0;

    for (let i = 0; i < biomeImageData.data.length / 4; i++) {
      if (i % size === 0) {
        x = 0;
      }

      if (!workArray[x]) {
        workArray[x] = [];
      }

      let color = rgbToHex(biomeImageData.data[i*4], biomeImageData.data[i*4 + 1], biomeImageData.data[i*4 + 2]);
      let waterColor = rgbToHex(biomeWaterData.data[i*4], biomeWaterData.data[i*4 + 1], biomeWaterData.data[i*4 + 2]);

      if (waterColor !== '#000000') {
        color = waterColor;
      }

      workArray[x].push(color);

      x++;
    }

    let localSize = size;

    const material = new THREE.MeshBasicMaterial();
    const matrix = new THREE.Matrix4();
    const threeColor = new THREE.Color();

    const geometryBox = new THREE.BoxGeometry( 1, 1, 1 );
    instanceMesh = new THREE.InstancedMesh( geometryBox, material, localSize * localSize );
    instanceMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
    instanceMesh.castShadow = true;
    instanceMesh.receiveShadow = true;
    scene.add( instanceMesh );

    for (let j = 0; j < localSize; j++) {
      for (let i = 0; i < localSize; i++) {
        matrix.setPosition(i, 0.5, j);
        instanceMesh.setMatrixAt(i + j * localSize, matrix );
        instanceXZ[`${i}:${j}`] = i + j * localSize;
        let color = workArray[i][j];
        let randomTaint = Math.random() - 0.5;
        if (randomTaint < -0.2 || randomTaint > 0.2) randomTaint = 0;
        color = pSBc(randomTaint / 2, color);

        const colorHex = Number('0x' + color.substring(1, color.length));

        instanceMesh.setColorAt(i + j * localSize, threeColor.setHex(colorHex));
      }
    }

    camera.position.set(localSize/2, 200, localSize);
    controls.target = new THREE.Vector3(localSize / 2, 100, localSize / 2);
  }

  function toggle3d() {
    if (mapHeight.style.display === 'block') {
      document.getElementById('toggle-3d').innerHTML = "Show 3D";
      document.getElementById('toolbar2d').style.display = "block";
      document.getElementById('toolbar3d').style.display = "none";
      mapHeight.style.display = 'none';
    } else {
      document.getElementById('toggle-3d').innerHTML = "Hide 3D";
      document.getElementById('toolbar2d').style.display = "none";
      document.getElementById('toolbar3d').style.display = "block";
      mapHeight.style.display = 'block';
      refresh3dContent();
    }
  }

  function switchColor(newColor) {
    color = newColor;
    console.log("color is now", color);
  }

  function changeBrushWidth() {
    width = parseInt(document.getElementById("brushWidth").value);
    console.log("pen width is now", width);
  }

  function toolPen() {
    tool = 'pen';
    document.getElementById('brushWidth').style.display = 'block';
    console.log('tool is now', tool)
  }

  function distance(x1, y1, x2, y2) {
    return Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
  }

  function toolFill() {
    tool = 'fill';
    document.getElementById('brushWidth').style.display = 'none';
    console.log('tool is now', tool)
  }

  function changeElevationWidth() {
    elevationWidth = parseInt(document.getElementById("elevationWidth").value);
    console.log("elevation width is now", elevationWidth);
  }

  function changeElevationHeight() {
    elevationHeight = parseInt(document.getElementById("elevationHeight").value);
    console.log("elevation height is now", elevationHeight);
  }

  function toolMove() {
    tool3d = 'move';
    document.getElementById('elevationWidth').style.display = 'none';
    document.getElementById('elevationHeight').style.display = 'none';
    controls.enabled = true;

    console.log('3d tool is now', tool3d)
  }

  function toolElevation() {
    tool3d = 'elevation';
    document.getElementById('elevationWidth').style.display = 'block';
    document.getElementById('elevationHeight').style.display = 'block';
    controls.enabled = false;

    console.log('3d tool is now', tool3d)
  }

  function toolColor() {
    tool3d = 'color';
    document.getElementById('elevationWidth').style.display = 'none';
    document.getElementById('elevationHeight').style.display = 'none';
    controls.enabled = false;

    console.log('3d tool is now', tool3d)
  }

  function pSBc(p,c0,c1,l) {
    let r,g,b,P,f,t,h,i=parseInt,m=Math.round,a=typeof(c1)=="string";
    if(typeof(p)!="number"||p<-1||p>1||typeof(c0)!="string"||(c0[0]!='r'&&c0[0]!='#')||(c1&&!a))return null;
    if(!this.pSBCr)this.pSBCr=(d)=>{
      let n=d.length,x={};
      if(n>9){
        [r,g,b,a]=d=d.split(","),n=d.length;
        if(n<3||n>4)return null;
        x.r=i(r[3]=="a"?r.slice(5):r.slice(4)),x.g=i(g),x.b=i(b),x.a=a?parseFloat(a):-1
      }else{
        if(n==8||n==6||n<4)return null;
        if(n<6)d="#"+d[1]+d[1]+d[2]+d[2]+d[3]+d[3]+(n>4?d[4]+d[4]:"");
        d=i(d.slice(1),16);
        if(n==9||n==5)x.r=d>>24&255,x.g=d>>16&255,x.b=d>>8&255,x.a=m((d&255)/0.255)/1000;
        else x.r=d>>16,x.g=d>>8&255,x.b=d&255,x.a=-1
      }return x};
    h=c0.length>9,h=a?c1.length>9?true:c1=="c"?!h:false:h,f=this.pSBCr(c0),P=p<0,t=c1&&c1!="c"?this.pSBCr(c1):P?{r:0,g:0,b:0,a:-1}:{r:255,g:255,b:255,a:-1},p=P?p*-1:p,P=1-p;
    if(!f||!t)return null;
    if(l)r=m(P*f.r+p*t.r),g=m(P*f.g+p*t.g),b=m(P*f.b+p*t.b);
    else r=m((P*f.r**2+p*t.r**2)**0.5),g=m((P*f.g**2+p*t.g**2)**0.5),b=m((P*f.b**2+p*t.b**2)**0.5);
    a=f.a,t=t.a,f=a>=0||t>=0,a=f?a<0?t:t<0?a:a*P+t*p:0;
    if(h)return"rgb"+(f?"a(":"(")+r+","+g+","+b+(f?","+m(a*1000)/1000:"")+")";
    else return"#"+(4294967296+r*16777216+g*65536+b*256+(f?m(a*255):0)).toString(16).slice(1,f?undefined:-2)
  }


  var isDrawing = false;

  function drawWithTool(res, e) {
    if (res === 'up' || res === 'out') {
      isDrawing = false;
    }

    if (tool === 'pen') {
      if (res === 'down') {
        isDrawing = true;

        res = 'move';
      }

      if (res === 'move' && isDrawing) {
        var box = activeCanvas.getBoundingClientRect();

        var x = e.clientX - box.left;
        var y = e.clientY - box.top;

        drawAliasedCircle(x, y);
      }
    } else if (tool === 'fill') {
      if (res === 'down') {
        const myImageData = activeContext.getImageData(0, 0, size, size);

        var box = activeCanvas.getBoundingClientRect();

        var coordX = e.clientX - box.left;
        var coordY = e.clientY - box.top;

        console.log("click coords is ", coordX, ":", coordY);

        const workArray = [];
        let x = 0;

        for (let i = 0; i < myImageData.data.length / 4; i++) {
          if (i % size === 0) {
            x = 0;
          }

          if (!workArray[x]) {
            workArray[x] = [];
          }

          workArray[x].push(rgbToHex(myImageData.data[i*4], myImageData.data[i*4 + 1], myImageData.data[i*4 + 2]));

          x++;
        }

        const toBeVisited = new Set();
        toBeVisited.add(`${coordX}:${coordY}`);
        const firstColor = workArray[coordX][coordY];
        const colorRgb = hexToRgb(color);

        const iterator = toBeVisited.values();
        let iteratorValue = iterator.next();

        while (!iteratorValue.done) {
          let [x, y] = iteratorValue.value.split(':');

          x = parseInt(x);
          y = parseInt(y);

          if (workArray[x][y] === firstColor) {
            workArray[x][y] = colorRgb;

            myImageData.data[(x + y * size) * 4] = colorRgb.r;
            myImageData.data[(x + y * size) * 4 + 1] = colorRgb.g;
            myImageData.data[(x + y * size) * 4 + 2] = colorRgb.b;

            handleNeighbor(x    , y + 1, toBeVisited, workArray, firstColor);
            handleNeighbor(x + 1, y,     toBeVisited, workArray, firstColor);
            handleNeighbor(x - 1, y,     toBeVisited, workArray, firstColor);
            handleNeighbor(x    , y - 1, toBeVisited, workArray, firstColor);
          }

          iteratorValue = iterator.next();
        }

        activeContext.putImageData(myImageData, 0, 0);
      }
    }
  }

  function handleNeighbor(posX, posY, toBeVisited, workArray, firstColor) {
    if (posY >= size || posY < 0 || posX >= size || posX < 0) {
      return;
    }

    const coords = `${posX}:${posY}`;

    if (workArray[posX][posY] === firstColor) {
      toBeVisited.add(coords);
    }
  }

  const rgbToHex = (r, g, b) => "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);

  function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function drawCircle(x, y) {
    activeContext.beginPath();
    activeContext.arc(x, y, width, 0, 2 * Math.PI);
    activeContext.fillStyle = color;
    activeContext.strokeStyle = color;
    activeContext.fill();
    activeContext.closePath();
  }

  function getCirclePosition(xc, yc, size) {
    const array = [];

    var x = size, y = 0, cd = 0;

    // middle line
    activeContext.rect(xc - x, yc, size<<1, 1);

    while (x > y) {
      cd -= (--x) - (++y);
      if (cd < 0) cd += x++;
      activeContext.rect(xc - y, yc - x, y<<1, 1);
      activeContext.rect(xc - x, yc - y, x<<1, 1);
      activeContext.rect(xc - x, yc + y, x<<1, 1);
      activeContext.rect(xc - y, yc + x, y<<1, 1);
    }

    return array;
  }

  function drawAliasedCircle(xc, yc) {
    activeContext.beginPath();

    var x = width, y = 0, cd = 0;

    // middle line
    activeContext.rect(xc - x, yc, width<<1, 1);

    while (x > y) {
      cd -= (--x) - (++y);
      if (cd < 0) cd += x++;
      activeContext.rect(xc - y, yc - x, y<<1, 1);
      activeContext.rect(xc - x, yc - y, x<<1, 1);
      activeContext.rect(xc - x, yc + y, x<<1, 1);
      activeContext.rect(xc - y, yc + x, y<<1, 1);
    }

    if (activeContext === ctxW && color === '#000000') {
      console.log('erase');
      activeContext.globalCompositeOperation = 'destination-out';
      activeContext.fillStyle = '#000000';
      activeContext.strokeStyle = '#000000';
    } else {
      activeContext.globalCompositeOperation = 'source-over';
      activeContext.fillStyle = color;
      activeContext.strokeStyle = color;
    }
    activeContext.fill();
    activeContext.closePath();
  }

  var logged = false;
  function logFirst(...msg) {
    if (!logged) {
      logged = true;
      console.log(...msg);
    }
  }

  var logEveryCpt = 0;
  function logEvery(nb, ...msg) {
    if (logEveryCpt > nb) {
      logEveryCpt = 0;
      console.log(...msg);
    }

    logEveryCpt++;
  }
</script>
</body>
</html>